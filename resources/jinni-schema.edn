{:enums
    {:ActionTypes
        {:description "General categories for actions"
        :values [
            :Exercise
            :Socialize
            :Internalize
            :Perceiving
            :Walking
            :Running
            :Dancing
            :Biking
            :Talking
            :Calling
            :Facetiming
            :Socializing
            :Partying
            :Messaging
            :Coding
            :Eating]}
    :ActionRelations
        {:description "Allowed Neo4j relations between players and actions"
        :values [:DID]}

    :ResourceTypes
        {:description "General categories for resources"
        :values [
            :Software
            :Music
        ]}
    :ResourceAccessibility
        {:description "How resources can be viewed and consumed by players"
        :values [
            :Public ;; anyone can see and use
            :Permissioned ;; publically viewable but requires access rights
            :Private ;; can only be seen and used with access rights
            :Secret ;; can only be seen and used with access rights
        ]}
    :ResourceRelations
        {:description "How avatars and actions interact with resources"
        :values [
            :MONITORS
            :CONTROLS
            :STEWARDS
            :CONSUMES
            :GENERATES
        ]}

    :Providers
        {:description "Valid Data Providers. 
                Unique game items that players can equip.
                Possible that a data provider can also be a data source. Or a data source could appear in multiple data providers."
        :values [
            :IphoneHealthKit
            :IwatchHealthKit
            :AndroidHealthConnect
            :Github
            :Spotify
            :MaliksMajik
            :MistralDalle
        ]}
    }

    :input-objects 
        {:SignedRequest
            {:description "Cryprographic signature and data to verify that the GQL query sent was signed by player.
                variable values aren't included in query so shouldnt cause recursion issue with different hashes.
                signature = eth_signMessage(query)
                nonce = optional value provided to player by server they are querying to prevent replay attacks"
            :fields {
                :_raw_query {:type String }
                :signature {:type (non-null String) }
                ;; :nonce {:type String :description "hash of variables for request"}
            }}

         :WidgetSettingInput
            {:description ""
            :fields {
                :id {:type (non-null String) :description "common global identifier for :Widget type e.g. spotify-pin-playist`"}
                :provider {:type (non-null :Providers)}
                :priority {:type Int :description "Hierarchy of widget in user profile setting. Relative, non-sequential e.g. can have two priority (1)s then an (8)"}
                
                ;; optional config per widget
                :provider_id {:type String :description "what to display from provider"}
                ;; avatar viewer
                :mood {:type (list String) :description "what to display from provider"}
                :stats {:type (list String) :description "what to display from provider"}
                :intentions {:type (list String) :description "what to display from provider"}
                ;; frontend params if needed?
                ;; :path {:type String :description "what to display from provider"}
                ;; :routeName {:type String :description "what to display from provider"}
                ;; :title {:type String :description "what to display from provider"}
            }}
        :RawInputData
            {:description "Any unprocessed data collected from data providers. GraphQL doesnt have a general <any> or <object> type so this is a catch all."
            :fields {
                :id {:type String} ;; uuid in data provider system
                :count {:type Int}
                :timestamp {:type String} ;; exact time action occured
                ;; timespan that action occured over
                :startTime {:type String}
                :endTime {:type String}
                :startDate {:type String}
                :endDate {:type String}
                :metadata {:type :RawInputMetadata}
            }}
        :RawInputMetadata
            {:description "Info on how data was collected from data provider provider. GraphQL doesnt have a general <any> or <object> type so this is a catch all."
            :fields {
                :id {:type String} ;; uuid in data provider system
                :clientRecordId {:type String} ;; uuid in data provider system
                :clientRecordVersion {:type String} ;; exact time action occured
                :device {:type String} ;; exact time action occured
                ;; timespan that action occured over
                :lastModifiedTime {:type String}
                :dataOrigin {:type String}
                :recordingMethod {:type String}
            }}
    }
    :objects
        {:Avatar {:fields {
            :id {:type (non-null String)}
            :name {:type String}
            :birthday {:type String}
            :homies {:type (list :Avatar)}
            :actions {:type (list :Action)}
        }}
        :Action {:fields {
            ;; make interface if we need abstract for incipient/consequential
            ;; :implements [:Action]
            :id {:type (non-null String)}
            :desc {:type String}
            :action_type {:type (non-null String)}
            :start_time {:type (non-null String)} ;; ISO string '2023-06-20T23:53:15.405Z'
            :end_time {:type (non-null String)} ;; ISO string '2023-06-20T23:53:15.405Z'
            :provider {:type (non-null :Providers)}
            :player {:type :Avatar} ;; Action may have multiple players? or no player if its projected?
        }}
        :Resource {:fields {
            ;; make interface if we need abstract for public/permissioned/private
            ;; :implements [:Resource]

            :uuid {:type (non-null String)}
            :provider_id {:type (non-null String)}
            :name {:type (non-null String)}
            :desc {:type String}
            :resource_type {:type String}
            :image {:type String}
            :url {:type String} ;; link to view data on resource
            :creators {:type (list Avatar)}
        }}
        :Divination
            ;; TODO is :Acrtion in DB but fields are mix of both :Action and :Resource
            ;; :implements [:Action]
            {:description ""
            :fields {
                :uuid {:type (non-null String) :description "global unique identifier"}
                :image {:type (non-null String) :description "binary image in json format to edit on next :Divination" }
                :hash {:type (non-null String) :description "hash of avatar widget settings creating unique analysis prompt to share across :Divinations" }
                :analysis {:type (non-null String) :description "How different body parts changed in divination and reasons why based on analysis prompt" }
                :start_time {:type (non-null String) :description "when :Divination process started" }
                :end_time {:type (non-null String) :description "when :Divination process ended" }
                ;; for initial :Divination with new intentions
                :prompt {:type String :description "analysis prompt used to read player data into jinni variation. nil if no new prompt" }
                :embed {:type String :description "LLM embeds for analysing prompts used. nil if no new prompt" }
            }}
        :Widget ;; TODO figure out how to make non-duplicate with input object
            {:description ""
            :fields {
                :id {:type (non-null String) :description "common global identifier for :Widget type e.g. 'spotify-pin-playist`"}
                :uuid {:type (non-null String) :description "unique global identifier for :Widget for player, provider, id and version"}
                :provider {:type (non-null :Providers)}
                :priority {:type Int :description "Hierarchy of widget in user profile setting. Relative, non-sequential e.g. can have two priority (1)s then an (8)"}
                
                ;; optional config per widget
                :provider_id {:type String :description "what to display from provider"}
                ;; avatar viewer
                :mood {:type (list String) :description "what to display from provider"}
                :stats {:type (list String) :description "what to display from provider"}
                :intentions {:type (list String) :description "what to display from provider"}
                ;; frontend params if needed?
                ;; :path {:type String :description "what to display from provider"}
                ;; :routeName {:type String :description "what to display from provider"}
                ;; :title {:type String :description "what to display from provider"}
            }}
        :Query {:fields {
            :players {:type (list :Avatar)}
            :get_playlists
                {:type       (list Resource)
                :description "gets players playlists to use in spells and widgets"
                :args       {:verification {:type :SignedRequest}
                            :provider {:type (non-null String)} ;; Spotify
                            :target_player {:type (non-null String)}}}

            ;; :jinni {:type (non-null :Avatar)
            ;;     :args {:player_id {:type String}}}
            ;; ;; get all of a players jin not just their primary.
            ;; ;; Here to remind me that i want people to bond to multiple jinn so i dont fuck up architecture
            ;; :my-jinn {:type (list :Avatar)
            ;;     :args {:player_id {:type String}}}
            
            ;; :player-actions {:type (list :Action)}
            ;;     :args {:player_id {:type (non-null String)
            ;;             :type (:type String)}
        }}
        :Mutation {:fields  {
            :submit_data
                {:type        (list ID)
                :description "Submit new game action data from players and return :Action UUIDs created"
                :args       {:verification {:type (non-null :SignedRequest)}
                            :raw_data {:type (list :RawInputData)}
                            :provider {:type (non-null :Providers)}
                            :action_type {:type (non-null String)} ;; Non-normalized action name from data provider. e.g. Step for android health
                            :player_id {:type (non-null String)}}}  ;; 0x ETH address
            
            :jinni_activate
                {:type       (non-null ID)
                :description "Registers a new jinni using ZKP that you have received a majik card"
                :args       {:verification {:type :SignedRequest} ;; TODO ZKP?
                            :majik_msg {:type (non-null String)} ;; Signed player_id by majik card
                            :player_id {:type (non-null String)}}} ;; 0x ETH address they will sign messages from
            :jinni_evolution
                {:type       ID ;; Divination :Action uuid, nil if nothing generated
                :description "Runs custom data analysis on players actions based on intentions they have set. Returns URL of new jinni image."
                :args       {:verification {:type :SignedRequest} ;; unneccesary if pulling from settings. 
                            :jinni_id {:type (non-null String)}
 
                            }}
            

            :jinni_set_widget
                {:type       (list (non-null ID))
                :description "Creates or updates settings for a widget to custyomize a players homepage.
                            Returns null if item for widget not equipped or invalid config"
                :args       {:verification {:type (non-null :SignedRequest)} ;; TODO ZKP?
                            :widgets {:type (list (non-null :WidgetSettingInput))}}} ;; 0x ETH address they will sign messages from
                
            :sync_provider_id
                {:type       String
                :description "adds a players username on a OAuth platform to their :Identity in our DB after granting access"
                :args       {:verification {:type :SignedRequest}
                            :provider {:type (non-null String)}
                            :player_id {:type (non-null String)}}} ;; 0x ETH address
            :sync_repos
                {:type       (list :Resource)
                :description "Adds github /gitlab/radicle repos as :Resources to player used for tracking commits as game :Actions"
                :args       {:verification {:type :SignedRequest}
                            :provider {:type (non-null String)}
                            :player_id {:type (non-null String)}}} ;; 0x ETH address
            :track_commits
                {:type       (list ID)
                :description "Gets all the commits by player since we last checked on the repos they've added to their :Identity
                            Returns UUID of :Actions for commits"
                :args       {:verification {:type :SignedRequest}
                            :provider {:type (non-null String)}
                            :player_id {:type (non-null String)}}} ;; 0x ETH address

            :spotify_follow
                {:type       String
                :description "follows other players from current players spotify account"
                :args       {:verification {:type (non-null :SignedRequest)}
                            :target_players {:type (list (non-null String))}}}
            :spotify_disco
                {:type       String
                :description "creates a local silent disco"
                :args       {:playlist_id {:type (non-null String)}}}
            }}
    }
}
